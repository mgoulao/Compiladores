%{
#include <stdio.h>
#include <assert.h>
#include <stdlib.h>
#include <string.h>
#include "node.h"
#include "tabid.h"
#include "postfix.h"
#include "y.tab.h"

extern FILE *yyout;

char *dupstr(const char *s);

static long brklbl[20], brkcnt; /* break/stop labels */
static long contlbl[20], contcnt; /* continue/repeat labels */

static char *extrns[100]; /* emit externs at the end only */
static int extcnt;

int lbl;
char *mklbl(int n) {
  static char buf[20];
  sprintf(buf, "_i%d", n);
  return strcpy(malloc(strlen(buf)+1),buf);
}

static char* mkfunc(char *s) {
  static char buf[80];
  strcpy(buf, "_");
  strcat(buf, s);
  return buf;
}

static void outstr(char *s) {
  while (*s) fprintf(yyout, pfCHAR, (unsigned char)*s++);
  fprintf(yyout, pfCHAR, 0);
}

static int sameVar(NODEPTR_TYPE p) {
  return strcmp(LEFT_CHILD(p)->value.s, LEFT_CHILD(RIGHT_CHILD(p))->value.s) ? 0x7fff : 2;
}

static int intOrString(Node *p){
  int l=LEFT_CHILD(p)->info %5;
  int r = RIGHT_CHILD(p)->info %5 ;
  if(l==2 && r==2) return MAX_COST;
  return  (l == 1 || l == 2) && (r == 1 || r == 2) ? 1 : MAX_COST; 
}

#define TRACE
static void yytrace(NODEPTR_TYPE p, int eruleno, int cost, int bestcost);


%}
%term LIST=';' EQ='=' ADD='+' SUB='-' MUL='*' DIV='/' MOD='%' LT='<' GT='>' NOT='~' BOR='|' BAND='&' DIM='['
%include "y.tab.h"
%%

body:	BODY(vars, stmts)
body:	BODY(body, return)

vars: 	NIL
vars:	VAR(var)
vars: 	VARS(vars, var)

stmt: 	PRINT(expr)	1 { fprintf(yyout, pfCALL pfTRASH, "_prints", pfWORD);  }

var:	INT_TYPE(type, IDENT)
var:	STR_TYPE(type, IDENT)
var:	ARR_TYPE(type, IDENT)

type:	NUMBER	1 {}
type:	STRING 	1 {}
type:	ARRAY	1 {}

stmtsAndEnd: STMTS(stmts, end)	1 { printf("LOL\n");  }
stmts: 	NIL	{  }
stmts: 	STMTS(stmts, stmt)


%! types
expr:	INTEGER		1 { fprintf(yyout, pfIMM, p->value.i);  }
expr:	STRING		1 { lbl++; fprintf(yyout, pfRODATA pfALIGN pfLABEL, mklbl(lbl)); outstr(p->value.s); fprintf(yyout, pfTEXT pfADDR, mklbl(lbl));  }
expr:	CHAR		1 { fprintf(yyout, pfIMM, p->value.i); }

%! expressions string and int
expr:   EQ(expr,expr)   1 { fprintf(yyout, pfEQ); }
expr:   NE(expr,expr)   1 { fprintf(yyout, pfNE); }
expr:   LT(expr,expr)   1 { fprintf(yyout, pfLT); }
expr:   LE(expr,expr)   1 { fprintf(yyout, pfLE); }
expr:   GT(expr,expr)   1 { fprintf(yyout, pfGT); }
expr:   GE(expr,expr)   1 { fprintf(yyout, pfGE); }


%! expressions int
expr:   MUL(expr,expr)  1 { fprintf(yyout, pfMUL); }
expr:   DIV(expr,expr)  1 { fprintf(yyout, pfDIV); }
expr:   MOD(expr,expr)  1 { fprintf(yyout, pfMOD); }

expr:	NEG(expr)	1 {}

%! expressions int and array
expr:   ADD(expr,expr)  1 { fprintf(yyout, pfADD); }
expr:   SUB(expr,expr)  1 { fprintf(yyout, pfSUB); }
expr:   DIV(expr,expr)  1 { fprintf(yyout, pfDIV); }
expr:   MOD(expr,expr)  1 { fprintf(yyout, pfMOD); }



%! if-elifs-else
stmt:	ELSE(ifElif, stmtsAndEnd)	1 {/* fprintf(yyout, pfLABEL, mklbl(LEFT_CHILD(p)->place));*/ }
if:	IF(cond, stmtsAndEnd)	1 {/* p->place = ++lbl; fprintf(yyout, pfJMP pfLABEL, mklbl(p->place), mklbl(LEFT_CHILD(p)->place));*/ }
ifElif:	IF_ELIFS(if, elifs)
%! if elif
elifs:	NIL
elifs:	ELIF(cond, STMTS(stmts, elifs))	1 {}

%! simple if (no else): uses only one label
stmt:	IF(cond, stmtsAndEnd)	1 { /*fprintf(yyout, pfLABEL, mklbl(LEFT_CHILD(p)->place));*/ }
cond:	expr		1 { p->place = ++lbl; fprintf(yyout, pfJZ, mklbl(p->place)); }

%! for loop
stmt:	FOR(forExprs, STMTS(stmts, end))	1 {/* brkcnt--; fprintf(yyout, pfJMP pfLABEL, mklbl(LEFT_CHILD(LEFT_CHILD(p))->place), mklbl(LEFT_CHILD(p)->place));*/ }

forExprs: FOR_EXPRS(FOR_EXPRS(expr, expr), expr) 1 { }

end:	return
end:	REPEAT		1 { fprintf(yyout, pfJMP, mklbl(contlbl[contcnt])); }
end:	STOP		1 { fprintf(yyout, pfJMP, mklbl(brklbl[brkcnt])); }

return: NIL		1 {}
return: RETURN(NIL)	1 { fprintf(yyout, pfLEAVE pfRET); }
return: RETURN(expr)	1 { fprintf(yyout, pfLEAVE pfRET); }

%! lvalues
lvalue:	lvalue		1 { fprintf(yyout, pfLOAD); }
lvalue:	INDEX(lvalue, expr) 1 { fprintf(yyout, pfIMM pfMUL pfADD, pfWORD); }
lvalue:	IDENT		1 { fprintf(yyout, pfLOCAL, p->value.i * (pfWORD/4)); }
expr:	ADDR(lvalue)	1 { fprintf(yyout, pfADDR, p->value.s);  }

%! assignment (multiple assignment)
assign: expr		1 { fprintf(yyout, pfDUP); }
expr:	ASSIGN(assign, lvalue)		1 { fprintf(yyout, pfSTORE); }
%! expr:	ASSIGN(expr, LOCAL)	1 { fprintf(yyout, pfDUP pfLOCA, RIGHT_CHILD(p)->value.i * (pfWORD/4)); }
%! expr:	ASSIGN(expr, ADDR)	1 { fprintf(yyout, pfDUP pfADDRA, RIGHT_CHILD(p)->value.s); }
%! expr:	ADDR			1 { fprintf(yyout, pfADDRV, p->value.s); }
stmt:	ALOC(aloc, lvalue)  		1 { fprintf(yyout, pfSTORE); }
aloc:	expr		1 { fprintf(yyout, pfIMM pfMUL pfALLOC pfSP, pfWORD); }



%%
#include "y.tab.h"
extern char **yynames;
extern int trace, errors;

void evaluate(Node* root) {
	if (errors) return;
  	//if (trace) printNode(root, stdout, yynames);
  	fprintf(yyout, pfTEXT pfALIGN pfGLOBL pfLABEL, "_main", pfFUNC, "_main");
  	yyselect(root);
  	fprintf(yyout, pfRET pfDATA);
}

void externs() {
	int i;
 	for (i = 0; i < extcnt; i++) {
		if (extrns[i])
			fprintf(yyout, pfEXTRN, extrns[i]);
	}
	fprintf(yyout, pfEXTRN pfEXTRN, "_prints", "_readi");
}

void variable(char* name, int isConst, Node* vectorSize, Node* init) {
  int i = 0, siz = 1;
	if (isConst) fprintf(yyout, pfRODATA);
  fprintf(yyout, pfDATA pfALIGN pfLABEL, pfOBJ, name);
  if (vectorSize->type == nodeInt) siz = vectorSize->value.i;
  if (vectorSize->attrib == INTEGER) {
    lbl++;
    fprintf(yyout, pfID pfLABEL, mklbl(lbl), mklbl(lbl));
  }
  if (init) {
    for (i = 0; i < init->value.sub.num; i++)
      //switch (init->CHILD(i)->attrib) {
        //case CTE: fprintf(yyout, pfWORD == 4 ? pfINTEGER : pfLONG, init->CHILD(i)->value.i); break;
	//case NAME: fprintf(yyout, pfID, init->CHILD(i)->value.s); break;
	//case STRING: { char *l = mklbl(++lbl);
	//		fprintf(yyout, pfRODATA pfALIGN pfLABEL, l);
	//		outstr(init->CHILD(i)->value.s);
	//		fprintf(yyout, pfDATA pfID, l); break; }
     // }
    if (i < siz)  fprintf(yyout, pfBYTE, pfWORD * (siz - i));
  }
  else fprintf(yyout, pfBYTE, pfWORD * siz);
  for (i = 0; i < extcnt; i++)
    if (extrns[i] && strcmp(extrns[i], name) == 0) extrns[i] = 0;
}

void publicVariable(char* name, Node* public, int isConst, Node* vectorSize, Node* init) {
	if (public->attrib == PUBLIC) {
  		fprintf(yyout, pfGLOBL, name);
	}
	variable(name, isConst, vectorSize, init);
}

void forwardVariable(char* name, int isConst, Node* vectorSize, Node* init) {
 	fprintf(yyout, pfEXTRN, name);
	variable(name,  isConst, vectorSize, init);
}

void forwardFunction(char* name) {
	extrns[extcnt++] = dupstr(mkfunc(name));
}


void burgFunction(char *name, int enter, Node* public, Node* type, Node *stmt) {
  int i;
  if (errors) return;
  //if (trace) printNode(stmt, 0, yynames);
  fflush(stdout);
  fprintf(yyout, pfTEXT pfALIGN pfGLOBL pfLABEL pfENTER, mkfunc(name), pfFUNC, mkfunc(name), enter * (pfWORD/4));
  yyselect(stmt);
  fprintf(yyout, pfLEAVE pfRET);
  freeNode(stmt);
  for (i = 0; i < extcnt; i++)
    if (extrns[i] && strcmp(extrns[i], mkfunc(name)) == 0) extrns[i] = 0;
}

void mainFunction(Node* body) {
	printf("EVALUATE MAIN or start-end in minor\n");
	burgFunction("main", 10, nilNode(NIL), intNode(NUMBER, 1), body);
}

static void yytrace(NODEPTR_TYPE p, int eruleno, int cost, int bestcost)
{
	extern int trace;
	int op = OP_LABEL(p);
	YYCONST char *tname = yytermname[op] ? yytermname[op] : "?";
	if (trace) fprintf(stderr, "0x%lx:%s matched %s with cost %d vs. %d\n", (long)p, tname, yystring[eruleno], cost, bestcost);
	if (cost >= MAX_COST && bestcost >= MAX_COST) {
	  extern char **yynames;
	  extern int debugNode;
	  fprintf(stderr, "0x%lx:%s NO MATCH %s with cost %d vs. %d\n", (long)p, tname, yystring[eruleno], cost, bestcost);
	  debugNode = 1;
	  //printNode(p, stderr, yynames);
	  debugNode = 0;
	}
}
