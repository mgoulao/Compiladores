%{
#include <stdio.h>
#include <assert.h>
#include <stdlib.h>
#include <string.h>
#include "node.h"
#include "tabid.h"
#include "postfix.h"
#include "y.tab.h"
#include "minor.h"

extern FILE *yyout;

char *dupstr(const char *s);

static long brklbl[20], brkcnt; /* break/stop labels */
static long contlbl[20], contcnt; /* continue/repeat labels */

static char *extrns[100]; /* emit externs at the end only */
static int extcnt;

int extrnPower = 0, extrnStrcmp = 0;

int lbl;
char *mklbl(int n) {
  static char buf[20];
  sprintf(buf, "_i%d", n);
  return strcpy(malloc(strlen(buf)+1),buf);
}

static char* mkfunc(char *s) {
  static char buf[80];
  strcpy(buf, "_");
  strcat(buf, s);
  return buf;
}

static void outstr(char *s) {
  while (*s) fprintf(yyout, pfCHAR, (unsigned char)*s++);
}

static void outCharAndInt(int c) {
	fprintf(yyout, pfCHAR, c);
}

static void aggregationStrRecur(Node* string) {
	if(string->attrib == TEXTSTRING && string->value.s != NULL) {
		outstr(string->value.s);
		return;
	}
	if(string->attrib == NUMBER) {
		outCharAndInt(string->value.i);
		return;
	}
	Node* leftNode = LEFT_CHILD(string);	
	Node* rightNode = RIGHT_CHILD(string);	
	if(leftNode != NULL && leftNode->attrib != NIL) aggregationStrRecur(leftNode);
	if(rightNode != NULL && rightNode->attrib != NIL) aggregationStrRecur(rightNode);
}

static void aggregationStr(Node* string) {
	aggregationStrRecur(string);
 	fprintf(yyout, pfCHAR, 0);
}

void minorPrint(Node* expr) {
	if(expr->info%10 == 1 || expr->info%10 == 0) 
		fprintf(yyout, pfCALL pfTRASH, "_printi", pfWORD); 
	else {
		fprintf(yyout, pfCALL pfTRASH, "_prints", pfWORD); 
	}
}

void functionCall(char* name) {
  int type = IDfind(name, (void*)IDtest);
  if (type%10 != 3) {
    fprintf(yyout, pfPUSH);
  }
}

static int intOrString(Node* p){
  int l=LEFT_CHILD(p)->info %5;
  int r = RIGHT_CHILD(p)->info %5 ;
  if(l==2 && r==2) return MAX_COST;
  return  (l == 1 || l == 2) && (r == 1 || r == 2) ? 1 : MAX_COST; 
}

static int onlyStr(Node* n) {
  return LEFT_CHILD(n)->info%10 == INFO_STR && RIGHT_CHILD(n)->info%10 == INFO_STR ? 1 : MAX_COST; 
} 

static int onlyInt(Node* n) {
  return LEFT_CHILD(n)->info%10 == INFO_INT && RIGHT_CHILD(n)->info%10 == INFO_INT ? 1 : MAX_COST;
}

static int exprDimension(int type) {
  switch(type%10) {
    case INFO_INT:
    case INFO_STR:
    case INFO_ARRAY:
	return pfWORD;
    case INFO_VOID:
	return 0;
  }
}

#define TRACE
static void yytrace(NODEPTR_TYPE p, int eruleno, int cost, int bestcost);


%}
%term LIST=';' EQ='=' ADD='+' SUB='-' MUL='*' DIV='/' MOD='%' NOT='~' LT='<' GT='>' OR='|' AND='&' DIM='[' CALL='(' READ='?'
%include "y.tab.h"
%%

function:	FUNCTION(FUNC_PARAMS(params), body)

params:	NIL
params: PARAMS(NIL, param)	1 {}
params:	PARAMS(params, param)	1 {}
param:	PARAM		1 {  }

body:	BODY(vars, stmts)
body:	BODY(BODY(vars, stmts), return)

vars: 	NIL
vars:	VAR(var)	1 {   }
vars: 	VARS(vars, var)	1 {   }

stmt: 	PRINT(expr)	1 { minorPrint(LEFT_CHILD(p)); }
stmt:	expr		1 { int size = exprDimension(p->info); if(size) fprintf(yyout, pfTRASH, size); }

var:	INT_TYPE(TYPE, IDENT)	{   }
var:	STR_TYPE(TYPE, IDENT)
var:	ARR_TYPE(TYPE, IDENT)

%!type:	NUMBER	1 {}
%!type:	STRING 	1 {}
%!type:	ARRAY	1 {}

stmtsAndEnd: STMTS(stmts, end)	1 {  }
stmts: 	NIL
stmts: 	STMTS(stmts, stmt)


%! types
expr:	INTEGER		1 { fprintf(yyout, pfIMM, p->value.i);  }
expr:	STRING		1 { lbl++; fprintf(yyout, pfRODATA pfALIGN pfLABEL, mklbl(lbl)); aggregationStr(p); fprintf(yyout, pfCHAR, 0); fprintf(yyout, pfTEXT pfADDR, mklbl(lbl));  }
expr:	CHAR		1 { fprintf(yyout, pfIMM, p->value.i); }

%! expressions string and int
expr:   EQ(expr, expr)  onlyInt { fprintf(yyout, pfEQ); }
expr:   NE(expr, expr)  onlyInt { fprintf(yyout, pfNE); }
expr:   LT(expr, expr)  onlyInt { fprintf(yyout, pfLT); }
expr:   LE(expr, expr)  onlyInt { fprintf(yyout, pfLE); }
expr:   GT(expr, expr)  onlyInt { fprintf(yyout, pfGT); }
expr:   GE(expr, expr)  onlyInt { fprintf(yyout, pfGE); }

expr:   EQ(expr, expr)  onlyStr {extrnStrcmp=1; fprintf(yyout,pfCALL pfTRASH pfPUSH pfIMM pfEQ, "_strcmp", 2 * pfWORD, 0); }
expr:   NE(expr, expr)  onlyStr {extrnStrcmp==1; fprintf(yyout,pfCALL pfTRASH pfPUSH pfIMM pfNE, "_strcmp", 2 * pfWORD, 0); }
expr:   LT(expr, expr)  onlyStr {extrnStrcmp=1; fprintf(yyout,pfCALL pfTRASH pfPUSH pfIMM pfLT, "_strcmp", 2 * pfWORD, 0); }
expr:   LE(expr, expr)  onlyStr {extrnStrcmp=1; fprintf(yyout,pfCALL pfTRASH pfPUSH pfIMM pfLE, "_strcmp", 2 * pfWORD, 0); }
expr:   GT(expr, expr)  onlyStr {extrnStrcmp=1; fprintf(yyout,pfCALL pfTRASH pfPUSH pfIMM pfGT, "_strcmp", 2 * pfWORD, 0); }
expr:   GE(expr, expr)  onlyStr {extrnStrcmp=1; fprintf(yyout,pfCALL pfTRASH pfPUSH pfIMM pfGE, "_strcmp", 2 * pfWORD, 0); }


%! expressions int
expr:   MUL(expr, expr) 1 { fprintf(yyout, pfMUL); }
expr:   DIV(expr, expr) 1 { fprintf(yyout, pfDIV); }
expr:   MOD(expr, expr) 1 { fprintf(yyout, pfMOD); }
expr:	POW(expr, expr)	1 { extrnPower = 1; fprintf(yyout, pfCALL pfPUSH, "_power"); }
expr:	AND(and, expr)	1 { fprintf(yyout, pfLABEL, mklbl(LEFT_CHILD(p)->place));  }
and:	expr		1 { p->place = ++lbl; fprintf(yyout, pfDUP pfJZ pfTRASH, mklbl(p->place), pfWORD); }
expr:	OR(or, expr)	1 { fprintf(yyout, pfLABEL, mklbl(LEFT_CHILD(p)->place));  }
or:	expr		1 { p->place = ++lbl; fprintf(yyout, pfDUP pfJNZ pfTRASH, mklbl(p->place), pfWORD);  }

expr:	NOT(expr)	1 { fprintf(yyout, pfIMM pfEQ, 0); }
expr:	NEG(expr)	1 { fprintf(yyout, pfNEG); }

%! expressions int and array
expr:   ADD(expr,expr)  1 { fprintf(yyout, pfADD); }
expr:   SUB(expr,expr)  1 { fprintf(yyout, pfSUB); }
expr:   DIV(expr,expr)  1 { fprintf(yyout, pfDIV); }
expr:   MOD(expr,expr)  1 { fprintf(yyout, pfMOD); }



%! call function
expr:	CALL(IDENT, args)	1 { fprintf(yyout, pfCALL pfTRASH, mkfunc(LEFT_CHILD(p)->value.s), (int)(RIGHT_CHILD(p)->place)); functionCall(LEFT_CHILD(p)->value.s);  }
expr:	NO_ARG_CALL	1 { fprintf(yyout, pfCALL, mkfunc(p->value.s)); functionCall(p->value.s); }

%! call _readi
expr:	READ		1 { fprintf(yyout, pfCALL pfPUSH, "_readi"); }

args:	ARGS(arg, NIL)	1 { p->place = LEFT_CHILD(p)->place; }
args:	ARGS(arg, args)	1 { p->place = ((LEFT_CHILD(p)->place)+(RIGHT_CHILD(p)->place));  }
arg:	expr		1 { p->place = pfWORD; /*TODO change size for array and strings*/ }



%! if-elifs-else
stmt: 	ifElif	1 { fprintf(yyout, pfLABEL, mklbl(p->place)); }
stmt:	ELSE(ifElif, stmtsAndEnd)	1 { fprintf(yyout, pfLABEL, mklbl(LEFT_CHILD(p)->place)); }
ifElif:	IF_ELIFS(if, elifs)	1 { p->place = ++lbl; fprintf(yyout, pfLABEL pfJMP pfLABEL, mklbl(LEFT_CHILD(p)->place), mklbl(p->place), mklbl(RIGHT_CHILD(p)->place)); }
if:	IF(cond, stmtsAndEnd)	1 { p->place = ++lbl; fprintf(yyout, pfJMP pfLABEL, mklbl(p->place),  mklbl(LEFT_CHILD(p)->place)); }
elifs:	NIL	{ p->place = ++lbl; fprintf(yyout, pfJMP, mklbl(p->place)); }
elifs:	ELIFS(elif, elifs)	1 { p->place = RIGHT_CHILD(p)->place; fprintf(yyout, pfLABEL, mklbl(LEFT_CHILD(p)->place)); }
elif: ELIF(cond, stmtsAndEnd)	1 { p->place = ++lbl; fprintf(yyout, pfJMP pfLABEL, mklbl(p->place), mklbl(LEFT_CHILD(p)->place)); }
cond:	expr		1 { p->place = ++lbl; fprintf(yyout, pfJZ, mklbl(p->place)); }



%! for loop
stmt:	FOR(forExprs, forEnd)	1 { brkcnt--; contcnt--; fprintf(yyout, pfJMP pfLABEL, mklbl(LEFT_CHILD(LEFT_CHILD(p))->place+1), mklbl(LEFT_CHILD(p)->place)); }
forExprs:	FOR_EXPRS(forStart, forCond)	1 { p->place = (brklbl[++brkcnt] = ++lbl); fprintf(yyout, pfJNZ, mklbl(lbl)); }
forCond:	FOR_EXPRS(expr, FOR_COND)	1 {   }
forStart:	FOR_EXPRS(expr, FOR_START)	1 { p->place = (contlbl[++contcnt] = ++lbl); int endToStart = ++lbl; fprintf(yyout, pfLABEL, mklbl(endToStart));  }
forEnd:		FOR_END(forStmts, expr)	1 { }
forStmts: stmtsAndEnd	1 { fprintf(yyout, pfLABEL, mklbl(contlbl[contcnt])); }


end:	return
end:	REPEAT		1 { fprintf(yyout, pfJMP, mklbl(contlbl[contcnt])); }
end:	STOP		1 { fprintf(yyout, pfJMP, mklbl(brklbl[brkcnt])); }

return: NIL		1 {}
return: RETURN(NIL)	1 { fprintf(yyout, pfLEAVE pfRET); }
return: RETURN(expr)	1 { fprintf(yyout, pfPOP pfLEAVE pfRET); }

%! lvalues
expr: lvalue		1 { fprintf(yyout, pfLOAD);  }
lvalue:	INDEX(lvector, expr) 1 { fprintf(yyout, pfIMM pfMUL pfADD, pfWORD); }
lvector: lvalue		1 { fprintf(yyout, pfLOAD);  }
%!lvalue: IDENT		1 { fprintf(yyout, pfLOCAL, p->value.i * (pfWORD/4)); }
lvalue:	IDENT		1 { fprintf(yyout, pfADDR, p->value.s); }
lvalue:	LOCAL		1 { fprintf(yyout, pfLOCAL, p->value.i); }
expr:	ADDR(lvalue)	1 {  }

%! assignment (multiple assignment)
expr:	ASSIGN(expr, LOCAL)	1 { fprintf(yyout, pfDUP pfLOCA, RIGHT_CHILD(p)->value.i); }
expr:	ASSIGN(expr, IDENT)	1 { fprintf(yyout, pfDUP pfADDRA, RIGHT_CHILD(p)->value.s); }
expr:	ASSIGN(assign, lvalue)	1 { fprintf(yyout, pfSTORE);  }
assign: expr		1 { fprintf(yyout, pfDUP); }
%! expr:	ADDR			1 { fprintf(yyout, pfADDRV, p->value.s); }
stmt:	ALOC(aloc, lvalue)  		1 { fprintf(yyout, pfSTORE); }
aloc:	expr		1 { fprintf(yyout, pfIMM pfMUL pfALLOC pfSP, pfWORD); }


%! optimizations

%%
#include "y.tab.h"
extern char **yynames;
extern int trace, errors;

void evaluate(Node* root) {
	if (errors) return;
  	//if (trace) printNode(root, stdout, yynames);
  	fprintf(yyout, pfTEXT pfALIGN pfGLOBL pfLABEL, "_main", pfFUNC, "_main");
  	yyselect(root);
  	fprintf(yyout, pfRET pfDATA);
}

void externs() {
	int i;
 	for (i = 0; i < extcnt; i++) {
		if (extrns[i])
			fprintf(yyout, pfEXTRN, extrns[i]);
	}
	fprintf(yyout, pfEXTRN pfEXTRN pfEXTRN, "_prints", "_printi", "_readi");
	if (extrnStrcmp) fprintf(yyout, pfEXTRN, "_strcmp");
	if (extrnPower) fprintf(yyout, pfEXTRN, "_power");
}

void array(Node* arrayNode) {
	if(arrayNode->attrib == NIL) return;
	array(LEFT_CHILD(arrayNode));
	fprintf(yyout, pfINTEGER, RIGHT_CHILD(arrayNode)->value.i);
}

void variable(char* name, int isConst, Node* vectorSize, Node* init) {
  int i = 0, siz = 1;
  if (isConst) fprintf(yyout, pfRODATA);
  fprintf(yyout, pfDATA pfALIGN pfLABEL, name);
  /*if (vectorSize->type == nodeInt) siz = vectorSize->value.i;
  if (vectorSize->attrib == INTEGER) {
    lbl++;
    fprintf(yyout, pfID pfLABEL, mklbl(lbl), mklbl(lbl));
  }*/
  
  if (init) {
    int type = IDfind(name, NULL);
    switch (type%10) {
	case 0: { 
	  int id = ++lbl;
	  fprintf(yyout, pfID pfLABEL, mklbl(id), mklbl(id));
	  int arraySize = LEFT_CHILD(RIGHT_CHILD(init))->value.i;
	  Node* arrayAssign = RIGHT_CHILD(RIGHT_CHILD(init));
	  if(arrayAssign->attrib != NIL) {
	    int i = 0;
	    Node* arrayInit = LEFT_CHILD(arrayAssign);
	    Node* currNode = arrayInit;
	    array(currNode);
	    while (currNode->attrib != NIL) {
 		currNode = LEFT_CHILD(currNode); 
		i++;  
	    }
	    for(i; i < arraySize; i++) fprintf(yyout, pfINTEGER, 0);
	   }
	}
	    break;
	case 1: fprintf(yyout, pfINTEGER, RIGHT_CHILD(init)->value.i);
		break;
	case 2: { int id = ++lbl;
		fprintf(yyout, pfID pfLABEL, mklbl(id), mklbl(id)); 
		aggregationStr(RIGHT_CHILD(init));
		break; }
        //case CTE: fprintf(yyout, pfWORD == 4 ? pfINTEGER : pfLONG, init->CHILD(i)->value.i); break;
	//case NAME: fprintf(yyout, pfID, init->CHILD(i)->value.s); break;
	//case STRING: { char *l = mklbl(++lbl);
	//		fprintf(yyout, pfRODATA pfALIGN pfLABEL, l);
	//		outstr(init->CHILD(i)->value.s);
	//		fprintf(yyout, pfDATA pfID, l); break; }
     }
    //if (i < siz)  fprintf(yyout, pfBYTE, pfWORD * (siz - i));
  }
  else fprintf(yyout, pfBYTE, pfWORD * siz);

	// remove from extrns
	for (i = 0; i < extcnt; i++)
    		if (extrns[i] && strcmp(extrns[i], name) == 0) extrns[i] = 0;
}

void publicVariable(char* name, Node* public, int isConst, Node* vectorSize, Node* init) {
	if (public->attrib == PUBLIC) {
  		fprintf(yyout, pfGLOBL, pfOBJ, name);
	}
	variable(name, isConst, vectorSize, init);
}

void forwardVariable(char* name, int isConst, Node* vectorSize, Node* init) {
 	fprintf(yyout, pfEXTRN, name);
	variable(name,  isConst, vectorSize, init);
}

void forwardFunction(char* name) {
	extrns[extcnt++] = dupstr(mkfunc(name));
}


void burgFunction(char *name, int enter, Node* public, Node* type, Node *function) {
  int i;
  if (errors) return;
  //if (trace) printNode(stmt, 0, yynames);
  fflush(stdout);
  fprintf(yyout, pfTEXT pfALIGN pfGLOBL pfLABEL pfENTER, mkfunc(name), pfFUNC, mkfunc(name), enter * (pfWORD/4));
  yyselect(function);
  fprintf(yyout, pfLEAVE pfRET);
  freeNode(function);
  for (i = 0; i < extcnt; i++)
    if (extrns[i] && strcmp(extrns[i], mkfunc(name)) == 0) extrns[i] = 0;
}

void mainFunction(Node* body, int enter) {
	printf("EVALUATE MAIN or start-end in minor\n");
	burgFunction("main", enter, nilNode(NIL), intNode(NUMBER, 1), binNode(FUNCTION, uniNode(FUNC_PARAMS, nilNode(NIL)), body));
}


static void yytrace(NODEPTR_TYPE p, int eruleno, int cost, int bestcost)
{
	extern int trace;
	int op = OP_LABEL(p);
	YYCONST char *tname = yytermname[op] ? yytermname[op] : "?";
	if (trace) fprintf(stderr, "0x%lx:%s matched %s with cost %d vs. %d\n", (long)p, tname, yystring[eruleno], cost, bestcost);
	if (cost >= MAX_COST && bestcost >= MAX_COST) {
	  extern char **yynames;
	  extern int debugNode;
	  fprintf(stderr, "0x%lx:%s NO MATCH %s with cost %d vs. %d\n", (long)p, tname, yystring[eruleno], cost, bestcost);
	  debugNode = 1;
	  //printNode(p, stderr, yynames);
	  debugNode = 0;
	}
}

